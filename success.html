<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Thank You for Your Order</title>
  <link rel="stylesheet" href="/assets/css/styles.css" />
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:#f7f7fb;color:#111;margin:0}
    .container{max-width:720px;margin:32px auto;padding:0 16px}
    .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:18px}
    .muted{color:#6b7280}
    .btn{height:40px;border:1px solid #d1d5db;background:#111;color:#fff;border-radius:10px;padding:0 14px;font-weight:700;cursor:pointer;text-decoration:none;display:inline-flex;align-items:center;justify-content:center}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;justify-content:space-between}
    .val{font-weight:700}
    table{width:100%;border-collapse:collapse;margin-top:16px}
    th,td{padding:8px;border-bottom:1px solid #e5e7eb;text-align:left}
    th{text-align:left;background:#f9fafb}
    .ok{color:#065f46;font-weight:700}
    .warn{color:#92400e}
    .err{color:#b91c1c}
  </style>
</head>
<body>
  <main class="container">
    <div class="card">
      <h1 style="margin:0 0 8px">Thank you for your order!</h1>
      <div class="muted" id="status">Finalizing your receipt…</div>

      <div id="details" style="margin-top:14px;display:none">
        <div class="row"><div>Order #</div><div class="val" id="ordId">—</div></div>
        <div class="row"><div>Paid</div><div class="val" id="paid">$0.00</div></div>
        <div class="row"><div>Email</div><div class="val" id="email">—</div></div>

        <table id="orderTable" style="display:none">
          <thead>
            <tr><th>Item</th><th>Qty</th><th style="text-align:right">Price</th><th style="text-align:right">Line</th></tr>
          </thead>
          <tbody id="orderLines"></tbody>
          <tfoot>
            <tr>
              <td colspan="3" style="text-align:right;font-weight:700">Total</td>
              <td id="orderTotal" style="font-weight:700;text-align:right">$0.00</td>
            </tr>
          </tfoot>
        </table>
        <div id="attendeeBlock" style="display:none;margin-top:16px">
          <h2 style="margin:0 0 6px;font-size:18px">Attendee details</h2>
          <div class="muted" style="margin-bottom:8px">Items and notes saved with your order.</div>
          <div id="attendeeDetails"></div>
        </div>

      </div>

      <div style="margin-top:16px;display:flex;gap:10px;flex-wrap:wrap">
        <a class="btn" href="/home.html">Back to Home</a>
        <a class="btn" href="/order.html" id="newOrderBtn">New Order</a>
      </div>
    </div>
  </main>

  <script>
  (function(){
    const q = new URLSearchParams(location.search);
    const sid = q.get('sid') || q.get('session_id');
    const nowTs = () => Date.now();


    function esc(v){
      return String(v ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;")
        .replaceAll("'","&#39;");
    }
    function norm(s){
      return String(s||"").toLowerCase().replace(/\s+/g," ").trim();
    }

    // Deep-scan order object for anything that looks like a note/instruction and
    // keep nearby context (attendee + item title) when possible.
    function collectNoteEntries(order){
      const out = [];
      const seen = new Set();

      const NOTE_KEY_RE = /(note|notes|instruction|instructions|special|diet|allergy|comment|request)/i;
      const CONTEXT_KEYS = ["attendee","attendeeName","name","fullName","person","personName","member","memberName","customerName",
                            "itemName","title","label","banquet","banquetName","entree","meal","addon","product","sku","id"];

      function walk(node, path, ctx){
        if (!node) return;
        if (typeof node === "string" || typeof node === "number" || typeof node === "boolean") return;

        // Arrays
        if (Array.isArray(node)) {
          node.forEach((v,i)=> walk(v, path.concat([i]), ctx));
          return;
        }

        // Objects
        if (typeof node === "object") {
          const nextCtx = Object.assign({}, ctx);

          // harvest context from common keys
          for (const k of Object.keys(node)) {
            if (!CONTEXT_KEYS.includes(k)) continue;
            const v = node[k];
            if (typeof v === "string" && v.trim()) nextCtx[k] = v.trim();
          }

          // harvest note-like keys
          for (const [k,v] of Object.entries(node)) {
            if (!NOTE_KEY_RE.test(k)) continue;
            if (typeof v !== "string") continue;
            const val = v.trim();
            if (!val) continue;

            const key = path.join(".") + ":" + k + ":" + val;
            if (seen.has(key)) continue;
            seen.add(key);

            out.push({
              note: val,
              key: k,
              path: path.concat([k]).join("."),
              attendee: nextCtx.attendeeName || nextCtx.attendee || nextCtx.name || nextCtx.fullName || nextCtx.personName || nextCtx.memberName || "",
              item: nextCtx.itemName || nextCtx.title || nextCtx.label || nextCtx.banquetName || nextCtx.banquet || nextCtx.product || "",
              entree: nextCtx.entree || nextCtx.meal || "",
              id: nextCtx.id || nextCtx.sku || ""
            });
          }

          // continue traversal
          for (const [k,v] of Object.entries(node)) {
            walk(v, path.concat([k]), nextCtx);
          }
        }
      }

      walk(order, ["order"], {});
      return out;
    }

    function renderAttendeeDetails(ord){
      const block = document.getElementById("attendeeBlock");
      const holder = document.getElementById("attendeeDetails");
      if (!block || !holder || !ord) return;

      const entries = collectNoteEntries(ord);

      // Build best-effort attendee -> items list.
      // First try explicit attendees array if present.
      const groups = new Map();

      function add(attName, itemName, note){
        const a = attName && attName.trim() ? attName.trim() : "Order notes";
        if (!groups.has(a)) groups.set(a, []);
        groups.get(a).push({ item: itemName || "", note: note || "" });
      }

      const attArr = Array.isArray(ord.attendees) ? ord.attendees : null;
      if (attArr && attArr.length) {
        attArr.forEach(a=>{
          const an = a.name || a.attendeeName || a.fullName || a.label || "Attendee";
          // look for common selections arrays
          const buckets = ["banquets","addons","items","catalog","orders","selections","purchases","products"];
          let any = false;
          buckets.forEach(bk=>{
            if (!Array.isArray(a[bk])) return;
            a[bk].forEach(it=>{
              const nm = it.itemName || it.title || it.label || it.name || "";
              const nt = it.note || it.notes || it.attendeeNote || it.specialInstructions || (it.meta && (it.meta.note || it.meta.notes)) || "";
              if (nm || nt) {
                add(an, nm, nt);
                any = true;
              }
            });
          });
          if (!any) {
            // fallback: attach any note entries discovered under this attendee object
            const local = collectNoteEntries(a);
            local.forEach(e=> add(an, e.item || e.entree || "", e.note));
          }
        });
      } else if (entries.length) {
        // No explicit attendees array: try to group scanned note entries by attendee field
        entries.forEach(e=>{
          const label = (e.item ? e.item : "") + (e.entree ? (" ("+e.entree+")") : "");
          add(e.attendee || "", label, e.note);
        });
      }

      // If we still don't have anything, don't show the block
      if (!groups.size) return;

      // Deduplicate & render
      let html = "";
      for (const [att, items] of groups.entries()) {
        const seen = new Set();
        const clean = [];
        items.forEach(x=>{
          const k = norm(att)+"|"+norm(x.item)+"|"+norm(x.note);
          if (seen.has(k)) return;
          seen.add(k);
          if (!x.item && !x.note) return;
          clean.push(x);
        });

        html += `<div style="border:1px solid #e5e7eb;border-radius:12px;padding:12px;margin:10px 0;background:#fff">` +
                `<div style="font-weight:800;margin-bottom:6px">${esc(att)}</div>`;

        clean.forEach(x=>{
          html += `<div style="margin:8px 0">` +
                  (x.item ? `<div>${esc(x.item)}</div>` : ``) +
                  (x.note ? `<div class="muted" style="font-size:12px;margin-top:2px"><b>Note:</b> ${esc(x.note)}</div>` : ``) +
                  `</div>`;
        });

        html += `</div>`;
      }

      holder.innerHTML = html;
      block.style.display = "block";
    }

    // Clear cart and notify other tabs
    try {
      if (window.Cart && Cart.clear) Cart.clear();
      localStorage.removeItem('amaranth_cart');
      localStorage.setItem('amaranth_cart_ping', String(Date.now()));
    } catch(e){}

    const status  = document.getElementById('status');
    const details = document.getElementById('details');

    if (!sid) {
      status.textContent = 'Payment completed, but no session id was provided.';
      return;
    }

    // ---- 1) Finalize (SAVES the order + sends emails)
    fetch('/api/router?action=finalize_checkout', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ sid })
    })
    .then(r => r.json())
    .then(async (j) => {
      if (!j || j.error) {
        status.textContent = (j && j.error) ? j.error : 'Could not finalize order.';
        return;
      }

      // Belt & suspenders: idempotent GET finalize in case POST had any hiccup.
      fetch('/api/router?type=finalize_order&sid=' + encodeURIComponent(sid) + '&t=' + nowTs(), { cache: 'no-store' })
        .catch(()=>{ /* safe to ignore */ });

      // ---- 2) Show confirmation basics using Stripe session data
      try {
        const sessResp = await fetch(
          '/api/router?type=checkout_session&id=' + encodeURIComponent(sid) + '&t=' + nowTs(),
          { cache: 'no-store' }
        );
        const s = await sessResp.json().catch(()=>null);

        if (s && s.id) {
          status.textContent = 'Payment confirmed.';
          details.style.display = 'block';
          document.getElementById('ordId').textContent = s.id;
          const total = (s.amount_total||0)/100;
          document.getElementById('paid').textContent =
            total.toLocaleString(undefined,{style:'currency',currency:'USD'});
          document.getElementById('email').textContent = (s.customer_details && s.customer_details.email) || '—';
          document.getElementById('orderTotal').textContent =
            total.toLocaleString(undefined,{style:'currency',currency:'USD'});
        } else {
          status.textContent = 'Payment confirmed.';
        }
      } catch(_) {
        status.textContent = 'Payment confirmed.';
      }

      // ---- 3) Try to load the single saved order (UNWRAP the { order } shape)
      let rows = [];
      try {
        const orderResp = await fetch(
          '/api/router?type=order&oid=' + encodeURIComponent(sid) + '&t=' + nowTs(),
          { cache: 'no-store' }
        );
        const orderJson = await orderResp.json().catch(()=>null);
        const ord = orderJson && orderJson.order ? orderJson.order : null;
        if (ord) renderAttendeeDetails(ord);

        if (ord && Array.isArray(ord.lines)) {
          rows = ord.lines.map(li => ({
            item: li.itemName,
            qty: li.qty,
            price: (li.unitPrice || 0)/100,
            gross: (li.gross || (li.qty||1)*(li.unitPrice||0))/100
          }));
          const orderTotal = rows.reduce((s,r)=> s + Number(r.gross||0), 0);
          document.getElementById('orderTotal').textContent =
            orderTotal.toLocaleString(undefined,{style:'currency',currency:'USD'});
          renderAttendeeDetails(ord);
        }
      } catch(_) { /* fall through to list */ }

      // Fallback: scan the rows list for this sid
      if (!rows.length) {
        const listResp = await fetch(
          '/api/router?type=orders&t=' + nowTs(),
          { cache: 'no-store' }
        ).catch(()=>null);
        const all = listResp ? await listResp.json().catch(()=>null) : null;
        rows = (all && Array.isArray(all.rows) ? all.rows : []).filter(r => r.id === sid);
      }

      // Render lines if present
      if (rows.length) {
        const tbody = document.getElementById('orderLines');
        tbody.innerHTML = rows.map(r =>
          `<tr>
            <td>${r.item}</td>
            <td>${r.qty}</td>
            <td style="text-align:right">$${Number(r.price||0).toFixed(2)}</td>
            <td style="text-align:right">$${Number(r.gross||0).toFixed(2)}</td>
          </tr>`
        ).join('');
        document.getElementById('orderTable').style.display = 'table';
      }
    })
    .catch(()=>{
      status.textContent = 'Could not finalize order.';
    });
  })();
  </script>
</body>
</html>
